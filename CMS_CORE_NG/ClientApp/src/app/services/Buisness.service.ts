/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.9.4.0 (NJsonSchema v10.3.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const BASE_URL = new InjectionToken<string>('BASE_URL');

export interface IBuisnessService {
    getBuisnessByEmailId(email: string | null, currentBusinessId: number | null): Observable<BuisnessVm | null>;
    getCurrentBuisnessByEmail(email: string | null): Observable<BusinessNamesPicUserIdVM | null>;
    getListOfBuisnesses(): Observable<BusinessForCardVM[] | null>;
    getListOfLatestUpdatedBuisnesses(): Observable<BusinessForCardVM[] | null>;
    getBusinessNamesPictures(): Observable<BusinessNamesPicturesVM[] | null>;
    getBusinessNamesPictUser(): Observable<BusinessNamesPicUserIdVM[] | null>;
    deleteBuisness(id: number): Observable<number>;
    getAreasList(): Observable<AreaVm[] | null>;
    createBuisnessWithFiles(): Observable<number>;
    createPaidTransactionWithPicture(): Observable<number>;
    createBarterDealWithPictures(): Observable<number>;
    createBarterDeal(model: BarterDealVM | null): Observable<number>;
    createPaidTransaction(model: PaidTransactionVM | null): Observable<number>;
    createJoinProjectWithPictures(): Observable<number>;
    businessInCollaboration(model: BusinessInCollaborationVM | null): Observable<number>;
    createJointProject(model: JointProjectVM | null): Observable<number>;
    createCollaborationType(collaborationType: CollaborationTypeVM | null): Observable<number>;
    getCollaborationTypes(): Observable<CollaborationTypeVM[] | null>;
    sendEmailToManager(model: any | null): Observable<boolean>;
    getManageEmail(): Observable<string | null>;
}

@Injectable()
export class BuisnessService implements IBuisnessService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getBuisnessByEmailId(email: string | null, currentBusinessId: number | null): Observable<BuisnessVm | null> {
        let url_ = this.baseUrl + "/api/Buisness/GetBuisnessByEmailId?";
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else if(email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (currentBusinessId === undefined)
            throw new Error("The parameter 'currentBusinessId' must be defined.");
        else if(currentBusinessId !== null)
            url_ += "currentBusinessId=" + encodeURIComponent("" + currentBusinessId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuisnessByEmailId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuisnessByEmailId(<any>response_);
                } catch (e) {
                    return <Observable<BuisnessVm | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<BuisnessVm | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuisnessByEmailId(response: HttpResponseBase): Observable<BuisnessVm | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BuisnessVm>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuisnessVm | null>(<any>null);
    }

    getCurrentBuisnessByEmail(email: string | null): Observable<BusinessNamesPicUserIdVM | null> {
        let url_ = this.baseUrl + "/api/Buisness/GetCurrentBuisnessByEmail?";
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else if(email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentBuisnessByEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentBuisnessByEmail(<any>response_);
                } catch (e) {
                    return <Observable<BusinessNamesPicUserIdVM | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessNamesPicUserIdVM | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentBuisnessByEmail(response: HttpResponseBase): Observable<BusinessNamesPicUserIdVM | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessNamesPicUserIdVM>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessNamesPicUserIdVM | null>(<any>null);
    }

    getListOfBuisnesses(): Observable<BusinessForCardVM[] | null> {
        let url_ = this.baseUrl + "/api/Buisness/GetListOfBuisnesses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListOfBuisnesses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListOfBuisnesses(<any>response_);
                } catch (e) {
                    return <Observable<BusinessForCardVM[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessForCardVM[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetListOfBuisnesses(response: HttpResponseBase): Observable<BusinessForCardVM[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessForCardVM[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessForCardVM[] | null>(<any>null);
    }

    getListOfLatestUpdatedBuisnesses(): Observable<BusinessForCardVM[] | null> {
        let url_ = this.baseUrl + "/api/Buisness/GetListOfLatestUpdatedBuisnesses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListOfLatestUpdatedBuisnesses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListOfLatestUpdatedBuisnesses(<any>response_);
                } catch (e) {
                    return <Observable<BusinessForCardVM[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessForCardVM[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetListOfLatestUpdatedBuisnesses(response: HttpResponseBase): Observable<BusinessForCardVM[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessForCardVM[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessForCardVM[] | null>(<any>null);
    }

    getBusinessNamesPictures(): Observable<BusinessNamesPicturesVM[] | null> {
        let url_ = this.baseUrl + "/api/Buisness/GetBusinessNamesPictures";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessNamesPictures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessNamesPictures(<any>response_);
                } catch (e) {
                    return <Observable<BusinessNamesPicturesVM[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessNamesPicturesVM[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessNamesPictures(response: HttpResponseBase): Observable<BusinessNamesPicturesVM[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessNamesPicturesVM[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessNamesPicturesVM[] | null>(<any>null);
    }

    getBusinessNamesPictUser(): Observable<BusinessNamesPicUserIdVM[] | null> {
        let url_ = this.baseUrl + "/api/Buisness/GetBusinessNamesPictUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessNamesPictUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessNamesPictUser(<any>response_);
                } catch (e) {
                    return <Observable<BusinessNamesPicUserIdVM[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessNamesPicUserIdVM[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessNamesPictUser(response: HttpResponseBase): Observable<BusinessNamesPicUserIdVM[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessNamesPicUserIdVM[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessNamesPicUserIdVM[] | null>(<any>null);
    }

    deleteBuisness(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Buisness/deleteBuisness?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBuisness(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBuisness(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBuisness(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    getAreasList(): Observable<AreaVm[] | null> {
        let url_ = this.baseUrl + "/api/Buisness/GetAreasList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreasList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreasList(<any>response_);
                } catch (e) {
                    return <Observable<AreaVm[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaVm[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAreasList(response: HttpResponseBase): Observable<AreaVm[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AreaVm[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaVm[] | null>(<any>null);
    }

    createBuisnessWithFiles(): Observable<number> {
        let url_ = this.baseUrl + "/api/Buisness/createBuisnessWithFiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBuisnessWithFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBuisnessWithFiles(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBuisnessWithFiles(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    createPaidTransactionWithPicture(): Observable<number> {
        let url_ = this.baseUrl + "/api/Buisness/createPaidTransactionWithPicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePaidTransactionWithPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePaidTransactionWithPicture(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePaidTransactionWithPicture(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    createBarterDealWithPictures(): Observable<number> {
        let url_ = this.baseUrl + "/api/Buisness/CreateBarterDealWithPictures";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBarterDealWithPictures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBarterDealWithPictures(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBarterDealWithPictures(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    createBarterDeal(model: BarterDealVM | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Buisness/createBarterDeal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBarterDeal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBarterDeal(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBarterDeal(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    createPaidTransaction(model: PaidTransactionVM | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Buisness/createPaidTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePaidTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePaidTransaction(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePaidTransaction(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    createJoinProjectWithPictures(): Observable<number> {
        let url_ = this.baseUrl + "/api/Buisness/createJoinProjectWithPictures";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateJoinProjectWithPictures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateJoinProjectWithPictures(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateJoinProjectWithPictures(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    businessInCollaboration(model: BusinessInCollaborationVM | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Buisness/CreateBusinessInCollaboration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBusinessInCollaboration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBusinessInCollaboration(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processBusinessInCollaboration(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    createJointProject(model: JointProjectVM | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Buisness/CreateJointProject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateJointProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateJointProject(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateJointProject(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    createCollaborationType(collaborationType: CollaborationTypeVM | null): Observable<number> {
        let url_ = this.baseUrl + "/api/Buisness/createCollaborationType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(collaborationType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCollaborationType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCollaborationType(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCollaborationType(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    getCollaborationTypes(): Observable<CollaborationTypeVM[] | null> {
        let url_ = this.baseUrl + "/api/Buisness/GetCollaborationTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollaborationTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollaborationTypes(<any>response_);
                } catch (e) {
                    return <Observable<CollaborationTypeVM[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<CollaborationTypeVM[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetCollaborationTypes(response: HttpResponseBase): Observable<CollaborationTypeVM[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CollaborationTypeVM[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CollaborationTypeVM[] | null>(<any>null);
    }

    sendEmailToManager(model: any | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Buisness?";
        if (model === undefined)
            throw new Error("The parameter 'model' must be defined.");
        else if(model !== null)
            url_ += "model=" + encodeURIComponent("" + model) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailToManager(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailToManager(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailToManager(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    getManageEmail(): Observable<string | null> {
        let url_ = this.baseUrl + "/api/Buisness";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManageEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManageEmail(<any>response_);
                } catch (e) {
                    return <Observable<string | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<string | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetManageEmail(response: HttpResponseBase): Observable<string | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string | null>(<any>null);
    }
}

export interface BuisnessVm {
    id: number;
    userId?: string | undefined;
    buisnessName?: string | undefined;
    businessEmailAddress?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    address?: string | undefined;
    actionDiscription?: string | undefined;
    discription?: string | undefined;
    buisnessWebSiteLink?: string | undefined;
    isdisplayBusinessOwnerName?: boolean | undefined;
    ispayingBuisness?: boolean | undefined;
    isburterBuisness?: boolean | undefined;
    iscollaborationBuisness?: boolean | undefined;
    isburterPossibleInAllCategory?: boolean | undefined;
    isopenToSuggestionsForBarter?: boolean | undefined;
    OptionalCollaborationDescription?: string | undefined;
    index?: number | undefined;
    coverPicture?: any | undefined;
    logoPicture?: any | undefined;
    coverPictureId?: string | undefined;
    logoPictureId?: string | undefined;
    product1?: string | undefined;
    product2?: string | undefined;
    barterProduct1?: string | undefined;
    barterProduct2?: string | undefined;
    Score?: number | undefined;
    ScoreStatus?: number | undefined;
    WantedGetHelpNotification?: boolean | undefined;
    WantedGetDailyNotification?: boolean | undefined;
    UpdatedBusinessStatus?: number | undefined;
    views?: number | undefined;
    tags?: string | undefined;
    lastupdatedStartDate?: Date | undefined;
    ownerName?: string | undefined;
    listOfAll4buisnessCategory?: BuisnessCategoryVm[] | undefined;
    buisnessCategory1?: BuisnessCategoryVm[] | undefined;
    buisnessCategory2?: BuisnessCategoryVm[] | undefined;
    buisnessCategory3?: BuisnessCategoryVm[] | undefined;
    buisnessCategory4?: BuisnessCategoryVm[] | undefined;
    buisnessBarterCategory1?: BuisnessBarterCategoryVm[] | undefined;
    buisnessBarterCategory2?: BuisnessBarterCategoryVm[] | undefined;
    BusinessCategoriesNotify?: BusinessCategoryNotifyVM[] | undefined;
    buisnessAreaList1?: BuisnessAreaVm[] | undefined;
    workPictureGuide?: GuideModel[] | undefined;
    BuisnessPictureVm?: BuisnessPictureVm[] | undefined;
}

export interface BuisnessCategoryVm {
    businessId?: number | undefined;
    categoryId: number;
    subCategoryId: number;
    combinationtId: number;
    isPossibleInBarter: boolean;
    categoryName?: string | undefined;
    subCategoryName?: string | undefined;
}

export interface BuisnessBarterCategoryVm {
    businessId?: number | undefined;
    categoryId: number;
    subCategoryId: number;
    combinationtId: number;
    categoryName?: string | undefined;
    subCategoryName?: string | undefined;
}

export interface BusinessCategoryNotifyVM {
    Id: number;
    BusinessId: number;
    categoryId: number;
    IfNotify?: boolean | undefined;
    Category?: CategoryVm | undefined;
}

export interface CategoryVm {
    Id: number;
    name?: string | undefined;
    subCategoryList?: SubCategoryVm[] | undefined;
}

export interface SubCategoryVm {
    Id: number;
    name?: string | undefined;
    CategorySubCategoryId: number;
}

export interface BuisnessAreaVm {
    id?: number | undefined;
    buisnessId?: number | undefined;
    areaId: number;
}

export interface GuideModel {
    workPicGuide?: string | undefined;
    picindex: number;
    picName?: string | undefined;
}

export interface BuisnessPictureVm {
    buisnessPictureId?: string | undefined;
    buisnessId: number;
    numberOfPicture: number;
}

export interface BusinessNamesPicUserIdVM {
    id: number;
    buisnessName?: string | undefined;
    logoPictureId: string;
    userId?: string | undefined;
    Score?: number | undefined;
}

export interface BusinessForCardVM {
    id: number;
    userId?: string | undefined;
    buisnessName?: string | undefined;
    businessEmailAddress?: string | undefined;
    actionDiscription?: string | undefined;
    isdisplayBusinessOwnerName?: boolean | undefined;
    ispayingBuisness?: boolean | undefined;
    isburterBuisness?: boolean | undefined;
    iscollaborationBuisness?: boolean | undefined;
    logoPictureId?: string | undefined;
    listOfAll4buisnessCategory?: BuisnessCategoryVm[] | undefined;
    index?: number | undefined;
    barterProduct1?: string | undefined;
    barterProduct2?: string | undefined;
    lastupdatedStartDate?: Date | undefined;
    ownerName?: string | undefined;
    Score?: number | undefined;
    buisnessCategory1?: BuisnessCategoryVm[] | undefined;
    buisnessCategory2?: BuisnessCategoryVm[] | undefined;
    buisnessCategory3?: BuisnessCategoryVm[] | undefined;
    buisnessCategory4?: BuisnessCategoryVm[] | undefined;
    buisnessAreaList1?: BuisnessAreaVm[] | undefined;
}

export interface BusinessNamesPicturesVM {
    id: number;
    buisnessName?: string | undefined;
    Score?: number;
    logoPictureId: string;
}

export interface AreaVm {
    id: number;
    name?: string | undefined;
}

export interface BarterDealVM {
    Id: number;
    ReportsBusinessId: number;
    PartnerBusinessId: number;
    ReportDate: Date;
    ReportCategorySubCategoryId: number;
    ReportDescriptionDeal?: string | undefined;
    PartnerCategorySubCategoryId: number;
    PartnerDescriptionDeal?: string | undefined;
    BusinessDescription?: string | undefined;
    QuotePartnerBusiness?: string | undefined;
    QuoteReportsBusiness?: string | undefined;
    ReportsBusinessPictureID?: string | undefined;
    Business1Picture?: any | undefined;
    PartnerBusinessPictureID?: string | undefined;
    Business2Picture?: any | undefined;
    JointExplanation?: string | undefined;
    ConfirmedByPartner: boolean;
    MoreLeisure?: boolean | undefined;
    MoreShopping?: boolean | undefined;
    IncreasingRevenue?: boolean | undefined;
    ReducingExpenses?: boolean | undefined;
    ReducingEffort?: boolean | undefined;
    IfDisplayedInCS?: boolean | undefined;
    ReportsBusiness?: BusinessNamesPicturesVM | undefined;
    PartnerBusiness?: BusinessNamesPicturesVM | undefined;
}

export interface PaidTransactionVM {
    Id: number;
    SupplierBusinessId: number;
    ConsumerBusinessId: number;
    CategorySubCategoryId: number;
    Description?: string | undefined;
    Review?: string | undefined;
    ScopTransactionNIS?: number | undefined;
    PictureID?: string | undefined;
    Availability?: boolean | undefined;
    Service?: boolean | undefined;
    Professionalism?: boolean | undefined;
    Price?: boolean | undefined;
    Flexable?: boolean | undefined;
    IfDisplayedInCS?: boolean | undefined;
    PaidTransactionPicture?: any | undefined;
    SupplierBusiness?: BusinessNamesPicturesVM | undefined;
    ConsumerBusiness?: BusinessNamesPicturesVM | undefined;
}

export interface BusinessInCollaborationVM extends BusinessNamesPicturesVM {
    PartInCollaboration?: string | undefined;
    IfReport?: boolean | undefined;
}

export interface JointProjectVM {
    Id: number;
    CollaborationTypeId: number;
    ReportDate: Date;
    HeaderCollaboration?: string | undefined;
    JointExplanation?: string | undefined;
    PictureId?: string | undefined;
    Picture?: any | undefined;
    MoreLeisure?: boolean | undefined;
    MoreShopping?: boolean | undefined;
    IncreasingRevenue?: boolean | undefined;
    ReducingExpenses?: boolean | undefined;
    ReducingEffort?: boolean | undefined;
    ConfirmedByPartners?: boolean | undefined;
    IfDisplayedInCS?: boolean | undefined;
    CollaborationType?: CollaborationTypeVM | undefined;
    BusinessesInCollaboration?: BusinessInCollaborationVM[] | undefined;
}

export interface CollaborationTypeVM {
    Id: number;
    Description?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}